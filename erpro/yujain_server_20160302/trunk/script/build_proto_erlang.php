<?php
//使用语法: php build_proto_erlang.php

$curPwd = getcwd();
$appRoot = dirname($curPwd);
chdir($appRoot);
$protoCommon = "proto/common.proto";
$protoGame = "proto/game.proto";

if (!file_exists($protoCommon)) {
    exit("文件{$protoCommon}不存在\r\n");
}
if (!file_exists($protoGame)) {
    exit("文件{$protoGame}不存在\r\n");
}


print "正在处理中......[请勿关闭窗口！]\r\n";

defined('CL') or define('CL', "\n");
$opTime = date('Y-m-d H:i:s');

// 分析协议定义文件
print "\n\n分析协议定义文件 \n";
print "".$appRoot."/".$protoCommon."\n";
print "".$appRoot."/".$protoGame."\n";

$contentAll = null;
$contentCommon = file_get_contents($protoCommon);
$contentGame = file_get_contents($protoGame);
$contentAll = $contentCommon.$contentGame;

//过滤掉import
$find = 'import "common.proto";';
$contentAll = str_replace($find, '', $contentAll);
$contentAll = preg_replace("/(option java_package = )\"(\w+).(\w+)\";/", "", $contentAll);
$contentAll = preg_replace("/\/\/(.*)?\\\n/","\n",$contentAll);//去掉注释
$generator = new ProtoNifGenerator($appRoot,$opTime);
$hrlCode = $generator->gene_erlang_hrl($contentAll);
$hrlCodeHeader  = "%% Author: caochuncheng2002@gmail.com\n";
$hrlCodeHeader .= "%% Created: 2015-09-23\n";
$hrlCodeHeader .= "%% Description: proto erlang record hrl\n";
$hrlCodeHeader .= "%% This file is generated by script tool,Do not edit it.\n\n";
//$hrlCodeHeader .= "%% Generate Time:".$opTime." \n\n";
file_put_contents("hrl/all_pb.hrl", $hrlCodeHeader.$hrlCode);

$packErl = "config/src/proto/proto_pack.erl";
$packCode = $generator->gene_proto_pack_erl();
file_put_contents($packErl, $packCode);

$unpackErl = "config/src/proto/proto_unpack.erl";
$unpackCode = $generator->gene_proto_unpack_erl();
file_put_contents($unpackErl, $unpackCode);

print "\n\n生成文件如下： \n";
print "协议erlang record定义文件：".$appRoot."/"."hrl/all_pb.hrl\n";
print "协议pack erl code文件：".$appRoot."/".$packErl."\n";
print "协议pack erl code文件：".$appRoot."/".$unpackErl."\n";

class ProtoNifGenerator {

	private $allMessage = array();
    private $baseDir = null;
    private $opTime = null;
    
    public function __construct($baseDir,$opTime)
    {
    	$this->baseDir = $baseDir;
    	$this->opTime = $opTime;
		error_reporting(E_ERROR);
    }
    
    public function gene_erlang_hrl($string) {
    	$pb = new ProtoParse();
        $allMessage = $pb->parse($string);
        $this->allMessage = $allMessage;
    	$code = null;
    	foreach ($this->allMessage as $m) {
    		$recordName = $m->getName();
    		$fields = $m->getFields();
    		$rCode = "-record($recordName, {";
    		foreach($fields as $field) {
    			$default = $field->default;
    			if ($default != NULL && $default != '') {
    				$rCode .= "{$field->name}=$default,";
    			} else {
    				$rCode .= "{$field->name},";
    			}
    			
    		}
    		$code .= trim($rCode, ",")."})." . CL;
    	}
    	return $code;
    }
    
    private function gene_pack_field($fields,$isCommonProto,$isTrim){
    	$fieldCount = count($fields);
    	$strFields = $isCommonProto == true ? "1:8/integer-signed" : "";
    	for($i=0; $i<$fieldCount; $i++){
    		$field = $fields[$i];
    		$dataType = $field->dataType;
    		if( $field->type == "repeated" ){
    			$strFields .=  ",?PACK_LIST(". ($i+2). ",". $dataType .")";
    		}else{
    			if( $dataType =="bool" ){
    				$strFields .=  ",?PACK_BOOL(". ($i+2). ")";
    			}else if( $dataType =="int64" ){
    				$strFields .=  ",?PACK_LONG(". ($i+2). ")";
    			}else if( $dataType =="int32" ){
    				$strFields .=  ",?PACK_INT(". ($i+2). ")";
    			}else if( $dataType =="int16" ){
    				$strFields .=  ",?PACK_SHORT(". ($i+2). ")";
    			}else if( $dataType =="byte" ){
    				$strFields .=  ",?PACK_BYTE(". ($i+2). ")";
    			}else if( $dataType =="double" ){
    				$strFields .=  ",?PACK_FLOAT(". ($i+2). ")";
    			}else if( $dataType =="string" ){
    				$strFields .=  ",?PACK_STR(". ($i+2). ")";
    			}else{
    				$strFields .=  ",?PACK_TYPE(". ($i+2). ",". $dataType .")";
    			}
    		};
    	}
    	if( $isTrim && $fieldCount>0 ){
    		$strFields = ltrim($strFields, ",");
    	}
    	return $strFields;
    }
    
    public function gene_proto_pack_erl(){
    	$code  = "%% Author: caochuncheng2002@gmail.com\n";
    	$code .= "%% Created: 2015-09-23\n";
    	$code .= "%% Description: proto pack erl\n";
    	$code .= "%% This file is generated by script tool,Do not edit it.\n\n";
    	//$code .= "%% Generate Time:".$this->opTime." \n\n";
    	$code .= "-module (proto_pack).".CL.CL;
    	$code .= "-compile([export_all]).".CL.CL;
        $code .= "-include(\"all_pb.hrl\").".CL;
        $code .= "-include(\"mm_define.hrl\").".CL.CL;
        $code .= "-define( LIST(L),(if L =:= undefined -> []; true -> L end )).".CL;
        $code .= "-define( TOINT(I),(if is_integer(I) -> I; is_float(I) -> round(I); I==undefined -> 0; true -> throw({bad_type_for_int,I,R}) end )).".CL;
        $code .= "-define( TOINT2(I),(if is_integer(I) -> I; is_float(I) -> round(I); I==undefined -> 0; true -> throw({bad_type_for_int,I}) end )).".CL;
        $code .= "-define( PACK_LONG(N),(?TOINT(element(N,R))):64/integer-signed ).".CL;
        $code .= "-define( PACK_INT(N),(?TOINT(element(N,R))):32/integer-signed ).".CL;
        $code .= "-define( PACK_SHORT(N),(?TOINT(element(N,R))):16/integer-signed ).".CL;
        $code .= "-define( PACK_BYTE(N),(?TOINT(element(N,R))):8/integer-signed ).".CL;
        $code .= "-define( PACK_BOOL(N),(if(element(N,R)) -> 1; true -> 0 end):8/integer-signed ).".CL;
        $code .= "-define( PACK_STR(N),(pack_string( element(N,R) ))/binary ).".CL;
        $code .= "-define( PACK_FLOAT(N),(?TOINT(element(N,R))):64/big-float ).".CL;
        $code .= "-define( PACK_LIST(N,T),(length(?LIST(element(N,R)))):16,(pack_list(T, ?LIST(element(N,R))))/binary).".CL;
        $code .= "-define( PACK_TYPE(N,T),(pack(T, element(N,R)))/binary ).".CL;

        //公共结构
        $code .= CL."%% common proto ".CL;
        $code .= "pack(_, undefined) ->".CL;
        $code .= "    <<0:8/integer-signed>>;".CL;
    	foreach ($this->allMessage as $m) {
    		$mName = $m->getName();
    		if("p_" == substr($mName,0,2)){
	    		$fields = $m->getFields();
	    		$code .= "pack(". $mName .", R) ->".CL;
	    		$code .= "    <<".$this->gene_pack_field($fields,true,true).">>;".CL;
    		}
    	}
    	$code .= "pack(_, _) ->".CL;
    	$code .= "    <<>>.".CL;
    	
    	//TOC协议包
    	$code .= CL.CL."%% toc proto".CL;
    	foreach ($this->allMessage as $m) {
    		$mName = $m->getName();
    		if("m_" == substr($mName,0,2) && "_toc" == substr($mName,strlen($mName) - 4,4)){
    			$nameMUP = strtoupper( substr($mName, 2,strlen($mName)-6) );
    			$fields = $m->getFields();
    			if( is_array($fields) && count($fields)>0 ){
    				$code .= "pack_toc(". $mName .", R) ->".CL;
    				//$code .= "    <<?". $nameMUP .":32".$this->gene_pack_field($fields,false,false).">>;".CL;
    				$code .= "    <<".$this->gene_pack_field($fields,false,true).">>;".CL;
    			}else{
    				$code .= "pack_toc(". $mName .", _R) ->".CL;
    				//$code .= "    <<?". $nameMUP .":32>>;".CL;
    				$code .= "    <<>>;".CL;
    			}
    		}
    	}
    	$code .= "pack_toc(_, _) ->".CL;
    	$code .= "    <<>>.".CL;
    	
    	$code .= CL.CL."%% base function".CL;
    	$code .= $this->getProtoPackCodeTail();
    	return $code;
    }
    
    private function getFieldTypeList($fields){
    	$strFieldTypes = "[";
    	$tmp = 0;
    	foreach($fields as $field) {
    		if( $tmp>0 ){
    			$strFieldTypes .= ",";
    		}
    		if( $field->type == "repeated" ){
    			$strFieldTypes .= "{repeated,". $field->dataType ."}";
    		}else{
    			$strFieldTypes .= $field->dataType;
    		}
    		$tmp++;
    	}
    	$strFieldTypes .= "]";
    	return $strFieldTypes;
    }
    
    public function gene_proto_unpack_erl(){
    	$code  = "%% Author: caochuncheng2002@gmail.com\n";
    	$code .= "%% Created: 2015-09-23\n";
    	$code .= "%% Description: proto pack erl\n";
    	$code .= "%% This file is generated by script tool,Do not edit it.\n\n";
    	//$code .= "%% Generate Time:".$this->opTime." \n\n";
    	$code .= "-module (proto_unpack).".CL.CL;
    	$code .= "-compile([export_all]).".CL.CL;
    	$code .= "-include(\"all_pb.hrl\").".CL;
    	$code .= "-include(\"mm_define.hrl\").".CL.CL;
    	$code .= "-define( FLOAT(F), (if is_float(F) -> trunc(F); true -> F end)).".CL;
    	$code .= "-define( STRING(Str), (if is_list(Str) -> Str; is_binary(Str) -> binary_to_list(Str); true -> Str end)).".CL;
    	$code .= "-define( UNPACK_REC(TypeList,Rec), unpack_record(TypeList, B, 2, Rec) ).".CL;
    	$code .= "-define( UNPACKTOS_REC(TypeList,Rec), element(1, unpack_record(TypeList, B, 2, Rec))).".CL;
    	
    	//公共结构
    	$code .= CL.CL."%% common proto ".CL;
    	foreach ($this->allMessage as $m) {
    		$mName = $m->getName();
    		if("p_" == substr($mName,0,2)){
    			$fields = $m->getFields();
    			$strFieldTypes = $this->getFieldTypeList( $m->getFields());
    			$code .= "unpack(". $mName .", B) ->".CL;
    			$code .= "    ?UNPACK_REC(".$strFieldTypes.", #".$mName."{});".CL;
    		}
    	}
    	$code .= "unpack(RecordTag, _Bin) ->".CL;
    	$code .= "    throw({illegal_record_tag, RecordTag}).".CL;
    	
    	
    	//TOS协议包
    	$code .= CL.CL.CL."%% tos proto".CL;
    	foreach ($this->allMessage as $m) {
    		$mName = $m->getName();
    		if("m_" == substr($mName,0,2) && "_tos" == substr($mName,strlen($mName) - 4,4)){
    			$strFieldTypes = $this->getFieldTypeList( $m->getFields()  );
    			$nameMUP = strtoupper( substr($mName, 2,strlen($mName)-6) );
    			$code .= "unpack_tos(?". $nameMUP .", B) ->".CL;
    			$code .= "    ?UNPACKTOS_REC(".$strFieldTypes.", #".$mName."{});".CL;
    		}
    	}
    	$code .= "unpack_tos(MethodID, _) ->".CL;
    	$code .= "    throw({illegal_method_id, MethodID}).".CL;
    	
    	$code .= CL.CL.$this->getProtoUnPackCodeTail();
    	
    	return $code;
    }
    
    private function getProtoUnPackCodeTail(){
    	return <<<EOT
unpack_record(_, <<>>, _, Record) -> {Record, <<>>};
unpack_record([], Bin, _, Record) -> {Record, Bin};
unpack_record([Type|T], Bin, I, Record) ->
    case Type of
        bool ->
            <<Val2:8/integer-signed, Rem/binary>> = Bin,
            Val = Val2 > 0;
        int64 ->
            <<Val:64/integer-signed, Rem/binary>> = Bin;
        int32 ->
            <<Val:32/integer-signed, Rem/binary>> = Bin;
        int16 ->
            <<Val:16/integer-signed, Rem/binary>> = Bin;
        byte ->
            <<Val:8/integer-signed, Rem/binary>> = Bin;
        double ->
            <<Val2:64/big-float, Rem/binary>> = Bin,
			Val = ?FLOAT(Val2);
        string ->
            <<Len:16, Val2:Len/binary-unit:8, Rem/binary>> = Bin,
			Val = ?STRING(Val2);
        {repeated, Type2} ->
            <<Len:16, Rem2/binary>> = Bin,
            {Val, Rem} = unpack_list(Type2, Rem2, Len, []);
        RecTag ->
            {Val, Rem} = unpack(RecTag, Bin)
    end,
    unpack_record(T, Rem, I+1, setelement(I, Record, Val)).
    
unpack_list(_Type, <<>>, _, Result) -> {lists:reverse(Result), <<>>};
unpack_list(_Type, Bin, 0, Result) -> {lists:reverse(Result), Bin};
unpack_list(Type, Bin, Len, Result) ->
    case Type of
        bool ->
            <<Val2:8/integer-signed, Rem/binary>> = Bin,
            Val = Val2 > 0;
        int64 ->
            <<Val:64/integer-signed, Rem/binary>> = Bin;
        int32 ->
            <<Val:32/integer-signed, Rem/binary>> = Bin;
        int16 ->
            <<Val:16/integer-signed, Rem/binary>> = Bin;
        byte ->
            <<Val:8/integer-signed, Rem/binary>> = Bin;
        double ->
            <<Val2:64/big-float, Rem/binary>> = Bin,
			Val = ?FLOAT(Val2);
        string ->
            <<Len:16, Val2:Len/binary-unit:8, Rem/binary>> = Bin,
			Val = ?STRING(Val2);
        RecTag ->
            {Val, Rem} = unpack(RecTag, Bin)
    end,
    unpack_list(Type, Rem, Len-1, [Val|Result]).
EOT;
    }
    
    private function getProtoPackCodeTail(){
    	return <<<EOT
pack_string(Data) ->
    Binary = if
                 Data =:= undefined -> <<>> ;
                 is_list(Data)      -> list_to_binary(Data);
                 is_integer(Data)   -> list_to_binary(integer_to_list(Data));
                 is_atom(Data)      -> atom_to_binary(Data,latin1);
                 is_tuple(Data)     -> list_to_binary(tuple_to_list(Data));
                 is_bitstring(Data) -> list_to_binary(bitstring_to_list(Data));
                 true               -> Data
             end,
    <<(size(Binary)):16,Binary/binary>>.
    
pack_list(Type, List) ->
    lists:foldl(fun
                   (Data, Acc) ->
                        case Type of
                            bool ->
                                <<Acc/binary,(if(Data) -> 1; true -> 0 end):8/integer-signed>>;
                            int64 ->
                                <<Acc/binary,?TOINT2(Data):64/integer-signed>>;
                            int32 ->
                                <<Acc/binary,?TOINT2(Data):32/integer-signed>>;
                            int16 ->
                                <<Acc/binary,?TOINT2(Data):16/integer-signed>>;
                            byte ->
                                <<Acc/binary,?TOINT2(Data):8/integer-signed>>;
                            double ->
                                <<Acc/binary,?TOINT2(Data):64/big-float>>;
                            string ->
                                <<Acc/binary,(pack_string( Data ))/binary>>;
                            _ ->
                                <<Acc/binary,(pack(Type, Data))/binary>>
                        end
                end, <<>>, List).
EOT;
    }
    
}// end class ProtoNifGenerator


class ProtoParse {
    private $messages = array();
    
    public function parse($contentAll) {
        //匹配所有的message
        if (preg_match_all("/message[ \t]+[\w]+[ \t\n]*{[ \t\n]+[^}]*}/i", $contentAll, $matches) > 0) {
            // 现在 matches数组的每个元素都是一个message
            foreach($matches[0] as $messageDesc) {
                $message = $this->_parse_message($messageDesc);
                $this->_push($message);
            }
            return $this->messages;
		} else {
			var_dump($matches);
		    throw new Exception ("proto定义文件格式出错:1");
		}
    }
    
    private function _push(ProtoMessage $message) {
        $this->messages[$message->getName()] = $message;
    }
    
    private function _parse_message($messageDesc) {
        if (preg_match("/message[ \t]+([\w]+)[ \t\n]?{([ \t\n]+[^}]*)}/i", $messageDesc, $messageDetail) > 0) {
            $messageName = $messageDetail[1];
            $messageBody = $messageDetail[2];
            $fields = explode("\n", $messageBody);
            $pm = new ProtoMessage($messageName);
            foreach($fields as $field) {
                if (trim($field) == '') {
                    continue;
                }
                //顺序匹配出  : 字段类型    数据类型  字段名称  字段唯一标示数字 默认值   
                $p = "/[ \t]*(required|optional|repeated)[ \t]+(\w+)[ \t]+(\w+)[ \t]*=[ \t]*([0-9]+)[ \t]*(\[default[ \t]*=[ \t]*([^\[\]]+)\])?;/";
                if (preg_match($p, $field, $f) > 0) {
                    $fieldObj = new ProtoField;
                    $fieldObj->type = $f[1];
                    $fieldObj->dataType = $f[2];
                    $fieldObj->name = strtolower($f[3]);
                    $fieldObj->unique = $f[4];
                    $fieldObj->default = isset($f[6]) ? ($f[6]) : NULL;
                    if($fieldObj->type == "repeated"){
                    	if($fieldObj->default == "0"){
                    		throw new Exception("proto定义文件格式出错:4 ->".$field);
                    	}
                    	if($fieldObj->default == "\"\""){
                    		$fieldObj->default = "[]";
                    	}
                    }else{
                    	if("p_" == substr($fieldObj->dataType,0,2)){
                    		$fieldObj->default = "undefined";
                    	}
                    }
                    $pm->push($fieldObj);
                } else {
                    throw new Exception("proto定义文件格式出错:3 ->".$field);
                }
            }
            return $pm;
        }
        throw new Exception("proto定义文件格式出错:2");
    }
}

class ProtoMessage {
    private $fields = array();
    
    private $name;
    
    public function __construct($name) {
        $this->name = $name;
    }
    
    public function getName() {
        return $this->name;
    }
    
    public function setName($name) {
        $this->name = $name;
    }
    
    public function push(ProtoField $field) {
        array_push($this->fields, $field);
    }
    
    public function getFields() {
        return $this->fields;
    }
}

class ProtoField {
    public $type;
    public $dataType;
    public $name;
    public $unique;
    public $default;
}

